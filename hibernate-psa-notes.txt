#######################
Hibernate
#######################

-> Hibernate is an ORM (Object relation mapping) tool
-> It helps developers map Java classes to database tables and automate CRUD operations (Create, Read, Update, Delete) without writing complex SQL queries.


Example: Entity Class Employee

@Entity
public class Employee {	
	@Id
	private int id;
	private String name;
	private float salary;
	
	//setters
	public void setId(int id) {
		this.id = id;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public void setSalary(float salary) {
		this.salary = salary;
	}

	//Getters
	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public float getSalary() {
		return salary;
	}
	
}

1. @Entity - â€œThis annotaion maps Java class to a table in the database.â€
2. @Id   - Indicates the primary key column, and is mandatory to define inside entity class


What is JPA?
JPA (Java Persistence API) is only a specification â€” meaning it is a set of interfaces and incomplete annotations

What is hibernate?
The Implementation of JPA is done in hibernate and other ORM tools like EclipseLink, OpenJPA, DataNucleus

Note:

ðŸ”¹ JPA = What to do
ðŸ”¹ Hibernate = How to do it (plus extra power)

######################
Hibernate Mappings
######################

a. OneToMany Mapping - One record in Table A matches with multiple record in Table B
-> @OneToMany
Example:
1. One Post has many Comments
2. One Hotel can have many reviews
3. One Hotel can have many Bookings
4. One Customer can place many Orders

b. ManyToOne Mapping - Multiple records in Table A matches with one record in Table B
-> @ManyToOne

c. ManyToMany Mapping - In Hibernate, a Many-to-Many relationship is used when each record in one table can be associated with multiple records in another table and vice versa. 
For example, 
a. Student can enroll in many Courses, and a Course can have many Students.
b. One Bus can travel to many stops, and one stop can have many buses

d. OneToOne Mapping - One Record in Table A matches with exactly One Record in Table B
-> @OneToOne
For Example:
One Person can have one KYC

###########################
Normalization
############################

1. 1NF (First Normal Form)
-> Should have atomic values
-> Identify each record uniquely
-> No repeating groups

2. 2NF (Second Normal Form)
-> Group the columns based on entity & seperate that to different tables

3. 3 NF (Third Normal Form)]
-> Remove all duplicate/redundant values
-> Ensure each record is uniquely identified by a Primary Key
-> Create relations between tables using Foreign Keys

What is Spring Data JPA?
############################

a. Spring Data JPA makes working with JPA easier by eliminating boilerplate code required for common database operations like saving, updating, deleting, and finding entities.

d. By default, Spring Data JPA uses Hibernate as the ORM (Object Relational Mapping) tool in Spring Boot applications (unless you configure another JPA provider manually).



What is repository layer in spring boot?
##############################################

-> The Repository Layer provides utility methods,
-> Using this utility method we can perform database CRUD Operations
-> Example of some utility methods save(), findById(), delete(), etc.


#######################################################
What is Dependency Injection (DI) in Spring Boot?
#######################################################
-> Dependency Injection is a design pattern used by Spring Boot to automatically create and manage objects (dependencies) your classes need â€” without you manually creating them.
-> Dependency Injection is a technique where objects (dependencies) are injected into a class by the framework (Spring) at runtime

Anology:
------------
Imagine you're building a house. You donâ€™t make the bricks yourself â€” you ask someone to provide them.
Similarly, Spring Boot provides the objects your app needs.


Why Use DI?
a. Loose coupling between components
b. Automatic lifecycle management (Spring manages the objects)

Why Use DI?
a. Loose coupling between components
b. Automatic lifecycle management (Spring manages the objects)

Example Of Tightly Coupled:
------------------------------

public class EmailService {
    public void sendEmail(String message) {
        System.out.println("Email sent: " + message);
    }
}

public class Notification {
    private EmailService emailService = new EmailService(); // creating directly

    public void send(String msg) {
        emailService.sendEmail(msg);
    }
}


Example Of Loosely Coupled:
------------------------------

// Step 1: Define an interface
public interface MessageService {
    void sendMessage(String msg);
}

// Step 2: Implement the interface
public class EmailService implements MessageService {
    public void sendMessage(String msg) {
        System.out.println("Email sent: " + msg);
    }
}

public class WhatsAppService implements MessageService {
    public void sendMessage(String msg) {
        System.out.println("WhatsApp message sent: " + msg);
    }
}

// Step 3: Notification depends on the interface, not the implementation
public class Notification {
    private MessageService messageService;

    // Inject dependency via constructor
    public Notification(MessageService messageService) {
        this.messageService = messageService;
    }

    public void send(String msg) {
        messageService.sendMessage(msg);
    }
}


public class Main {
    public static void main(String[] args) {
        // Step 2: Create the implementation instance
        MessageService emailService = new EmailService();

        // Step 3: Inject the dependency via constructor
        Notification notification = new Notification(emailService);

        // Use the Notification service
        notification.send("Hello! This is a test message.");
    }
}
########################
What is Spring IOC?
#########################
-> Spring IOC Container is the core of the Spring Framework.
-> It manages the lifecycle and Creation of application objects (called beans).
-> It creates, configures, and wires objects automatically based on configuration
-> Helps implement Dependency Injection (DI) easily.
-> Promotes loose coupling because your classes donâ€™t instantiate their dependencies directly.


##################################
Bean life cycle
#####################################

Bean is Created---->Dependencies Injected (@Autowired)----->Execution(Bean is use by the application)------>Destruction of the bean

####################
Junit
#####################
-> We performe testing at the code level. This called as Unit / Whitebox testing
-> When we create Spring boot project by default we will get Junit library

Annotations in Junit
--------------------
a. @Test:
-> Will run a method as a test case and report pass or fail
-> If we have more than one @Test method in same class then we can run that in sequence

Example 1:
----------
@SpringBootTest
class Demo1ApplicationTests {

	@Test
	void test1() {
		System.out.println("From test1");
	}
	
	@Test
	void test2() {
		System.out.println("From test2");
	}
	
	

}

Output:
------
From test1
From test2

b. @BeforeEach: It is used to signal that the annotated method should be executed before each @Test

Example:
--------
@SpringBootTest
class Demo1ApplicationTests {

	@Test
	void test1() {
		System.out.println("From test1");
	}
	
	@Test
	void test2() {
		System.out.println("From test2");
	}
	
	@BeforeEach
	public void beforeTest() {
		System.out.println("Before Test");
	}
	

}
Output
-------

Before Test
From test1
Before Test
From test2

c. @AfterEach: It is used to signal that the annotated method should be executed after each @Test

Example:
package com.demo1;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Demo1ApplicationTests {

	@Test
	void test1() {
		System.out.println("From test1");
	}
	
	@Test
	void test2() {
		System.out.println("From test2");
	}
	
	@BeforeEach
	public void beforeTest() {
		System.out.println("Before Test");
	}
	
	@AfterEach
	public void afterTest() {
		System.out.println("After Test");
	}
	

}
Output:
Before Test
From test1
After Test
Before Test
From test2
After Test

d. @BeforeAll: It is used to signal that the annotated method should be executed before all tests in the current test clas

Example:
--------
package com.demo1;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Demo1ApplicationTests {

	@Test
	void test1() {
		System.out.println("From test1");
	}
	
	@Test
	void test2() {
		System.out.println("From test2");
	}
	
	@BeforeEach
	public void beforeTest() {
		System.out.println("Before Test");
	}
	
	@AfterEach
	public void afterTest() {
		System.out.println("After Test");
	}
	
	@BeforeAll
	public static void  beforeAll() {
		System.out.println("Before All");
	}

}

Output:
------
Before All
Before Test
From test1
After Test
Before Test
From test2
After Test

e. @AfterAll: It is used to signal that the annotated method should be executed after all tests in the current test class

package com.demo1;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Demo1ApplicationTests {

	@Test
	void test1() {
		System.out.println("From test1");
	}
	
	@Test
	void test2() {
		System.out.println("From test2");
	}
	
	@BeforeEach
	public void beforeTest() {
		System.out.println("Before Test");
	}
	
	@AfterEach
	public void afterTest() {
		System.out.println("After Test");
	}
	
	@BeforeAll
	public static void  beforeAll() {
		System.out.println("Before All");
	}
	
	@AfterAll
	public static void  afterAll() {
		System.out.println("After All");
	}

}
Output:
---------
Before Test
From test1
After Test
Before Test
From test2
After Test
After All


What is Spring Data JPA?
############################

a. Spring Data JPA makes working with JPA easier by eliminating boilerplate code required for common database operations like saving, updating, deleting, and finding entities.

d. By default, Spring Data JPA uses Hibernate as the ORM (Object Relational Mapping) tool in Spring Boot applications (unless you configure another JPA provider manually).



What is repository layer in spring boot?
##############################################

-> The Repository Layer provides utility methods,
-> Using this utility method we can perform database CRUD Operations
-> Example of some utility methods save(), findById(), delete(), etc.

#######################################
Perform CRUD Operation using hibernate
########################################

Step 1: Connect to Database by using application.properties file and adding the following

spring.datasource.url=jdbc:mysql://localhost:3306/test_crud_db
spring.datasource.username=root
spring.datasource.password=test

spring.jpa.hibernate.ddl-auto=create

----------------------------
Step 2: Create Entity Class

package com.democrud.entity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name="employees")
public class Employee {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long id;
	
	@Column(name = "first_name", nullable = false, length = 45)
	private String firstName;
	
	@Column(name = "last_name", nullable = false, length = 45)
	private String lastName;
	
	@Column(name = "email_id", nullable = false, length = 256, unique = true)
	private String emailId;
	
	@Column(name="mobile", nullable = false, unique = true)
	private String mobile;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public String getEmailId() {
		return emailId;
	}

	public void setEmailId(String emailId) {
		this.emailId = emailId;
	}

	public String getMobile() {
		return mobile;
	}

	public void setMobile(String mobile) {
		this.mobile = mobile;
	}
	
	

}
----------------------------------------------------
