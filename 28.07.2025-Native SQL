############################
Native SQl Query
##########################
 -> Raw SQL can be written with hibernate
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
EmployeeRepositoryjava
---------------------
// Native SQL Query
   
   @Query(value= "SELECT * FROM employees WHERE email_id= ?1", nativeQuery = true)
   Optional <Employee> findByEmailUsingSQl(String email);
   
   @Query(value = "SELECT * FROM employees WHERE mobile = ?1", nativeQuery = true)
	Optional<Employee> findByMobileUsingSQl(String mobile);
   
   @Query(value="select * FROM employees WHERE email_id= ?1 and mobile= ?2", nativeQuery= true)
   Optional<Employee> findByMobileAndEmailUsingSql(String email, String mobile);

DemoCrudApplicationTests.Java
------------------------------
package com.demo_crud;

import java.util.List;
import java.util.Optional;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import com.demo_crud.entity.Employee;
import com.demo_crud.repository.EmployeeRepository;

@SpringBootTest
class DemoCrudApplicationTests {

	@Autowired
	private EmployeeRepository  employeeRepository;
	
  @Test
void findEmployeeByEmailNativeSql() {
	 
	 Optional<Employee> opEmp = employeeRepository.findByEmailUsingSQl("adam@gmail.com"); 
	 
	 if(opEmp.isPresent()) {
		 
		 Employee emp= opEmp.get();
		 System.out.println(emp.getId());
		 System.out.println(emp.getFirstName());
		 System.out.println(emp.getLastName());
		 System.out.println(emp.getEmailId());
		 System.out.println(emp.getMobile());
	 }else {
		 System.out.println("employee not found.");
	 }
		 
	 }
@Test
void findDetailsByMobileUsingNativeSql() {
Optional<Employee> opEmp = employeeRepository.findByMobileUsingSQl("9745898554");
if(opEmp.isPresent()) {
	 
	 Employee emp= opEmp.get();
	 System.out.println(emp.getId());
	 System.out.println(emp.getFirstName());
	 System.out.println(emp.getLastName());
	 System.out.println(emp.getEmailId());
	 System.out.println(emp.getMobile());
     }else {
    	 
    	 System.out.println("Mobile number is not fetched with any employees data");
     }
    }
@Test
void searchEmployeeByEmailAndMobileUsingNativeSql() {
Optional<Employee> opEmp = employeeRepository.findByMobileAndEmailUsingSql("honu@gmail.com", "9745898554");
if(opEmp.isPresent()) {
	 
	 Employee emp= opEmp.get();
	 System.out.println(emp.getId());
	 System.out.println(emp.getFirstName());
	 System.out.println(emp.getLastName());
	 System.out.println(emp.getEmailId());
	 System.out.println(emp.getMobile());

       }
   }
   
=====================================================================================

started OneToMany mapping concept
--------------------------------
lombok, we use to reduce the boilerplate 

add this in pom.xml file to use lombok in our spring boot project .

===================================================================
   
   <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>
    
==================================================================


let's dive into the project
=============================

create a demoapp sts project in STS.

path: src/main/java

uder that creata a enity package
com.dempapp.entity
=================
create 2 class under the same

Post.java
Comment.java

Comment.java
============
package com.demoapp.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
@Entity
@Getter
@Setter

public class Comment {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
private String content;

/*
 
//many to one mapping 
@ManyToOne
@JoinColumn(name = "post_id") //this will generate a foreign key so here "post_id" will become the foreign key inside the "comment" entity.
private Post post;

*/
	}
 
Post.java
=========
package com.demoapp.entity;

import java.util.List;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import lombok.Getter;
import lombok.Setter;
@Entity
@Getter
@Setter

public class Post {

	@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    @OneToMany
    @JoinColumn(name = "post_id")
    private List<Comment> comemnts;
	
}

======================
application.properties
======================

spring.application.name=demoapp
spring.datasource.url=jdbc:mysql://localhost:3306/mysqldb
spring.datasource.username=root
spring.datasource.password=test

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true



















 
Use this in pom.xml to avoid https problem, it is very optional of you face issues on https then you tru with this.
==================================================================================================================
 <ns:root  
  xmlns:ns="http://example.com/ns"  
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
  xsi:schemaLocation="http://example.com/ns example.xsd">
  <!-- ... -->  
</ns:root
