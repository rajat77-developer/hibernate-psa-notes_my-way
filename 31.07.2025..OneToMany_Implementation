ðŸ”¹ Now what happens when you do Lazy Fetch:
Post post = postRepository.findById(1L).orElseThrow();

-> Only the Post record (with ID 1) is loaded.
-> No Comment records are loaded yet.
-> we have to load comments explicitly
-> We can do this using @TRansactional annotaion

What Happens Without @Transactional

-> Post post = postRepository.findById(1L).orElseThrow();
-> List<Comment> comments = post.getComments(); // Lazy fetch
-> If fetch = FetchType.LAZY (default for @OneToMany):

-> The Post is fetched immediately.
-> The comments collection is not fetched yet.
-> Instead, Hibernate injects a proxy â€” a placeholder object.
-> Then, after the method ends, the Hibernate session is closed.

So when you later try:
-> comments.size(); // or iterate
-> Hibernate wants to fetch the comments, but it can't â€” session is closed.

ðŸš¨ Result:
-> LazyInitializationException: could not initialize proxy - no Session

âœ… What @Transactional Does
When you annotate your method like this:

@Transactional
public void getPostAndItsComments() {
    Post post = postRepository.findById(1L).orElseThrow();
    List<Comment> comments = post.getComments(); // Works now!
}

-> A Hibernate session is kept open for the entire method.
-> When you access post.getComments(), Hibernate can safely go to the DB and fetch the comments on demand.
-> This works perfectly with lazy loading.

Note:
-----------

| Annotation        | Definition                                                                                                               |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `@Entity`         | Declares the class as a JPA entity. It will be mapped to a table in the database.                                        |
| `@Id`             | Marks the field as the **primary key** of the entity.                                                                    |
| `@GeneratedValue` | Specifies how the primary key should be generated (e.g., auto-increment).                                                |
| `@Table`          | Specifies the table name in the database for this entity.                                                                |
| `@Column`         | Used to define column details like name, length, nullable, and uniqueness.                                               |
| `@OneToMany`      | Specifies a one-to-many relationship between two entities (e.g., one post has many comments).                            |
| `@ManyToOne`      | Specifies a many-to-one relationship (e.g., many comments belong to one post).                                           |
| `@OneToOne`       | Maps a one-to-one relationship between two entities (e.g., one person has one KYC).                                      |
| `@ManyToMany`     | Specifies a many-to-many relationship (e.g., student â†” courses).                                                         |
| `@JoinColumn`     | Defines the foreign key column in the child table that maps to the parent table.                                         |
| `@Query`          | Allows writing custom JPQL or native SQL queries inside repository methods.                                              |
| `@Transactional`  | Manages the database transaction for the method or class. Automatically commits on success and rolls back on exceptions. |


@Transactional
==============


com.blog.entity
==================
post.java
=========
package com.blog.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;

@Entity

public class Post {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	private String title;
	
	
	/*
	-> Here POST is related to comment as One To Many.
	->we can also use SET instead of List if you want to remove duplicate values.
	->"comments" variable is mapped with "post" variable inside the comment entity.  comment.java  --> private Post post;
	-> we are performing ByDirectional mapping here.
	*/
	@OneToMany(mappedBy ="post", cascade =CascadeType.ALL)
	private List<Comment> comments; 
	
	
	
	public List<Comment> getComments() {
		return comments;
	}
	public void setComments(List<Comment> comments) {
		this.comments = comments;
	}
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	
}

Comment.java
=============
package com.blog.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;

@Entity

public class Comment {


	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	private String content;
	
	
	
	//comment related to post as one
	
	
	@ManyToOne
	@JoinColumn(name="post_id")
	private Post post; //post is one object mapped to many objects 
	
	
	public Post getPost() {
		return post;
	}
	public void setPost(Post post) {
		this.post = post;
	}
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getContent() {
		return content;
	}
	public void setContent(String content) {
		this.content = content;
	}	
	
}
====================
com.blog.repository
====================
CommentRepository.java
----------------------
package com.blog.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.blog.entity.Comment;

public interface CommentRepository extends JpaRepository<Comment, Long>{

}

PostRepository.java
===================

package com.blog.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.blog.entity.Post;

public interface PostRepository  extends JpaRepository<Post, Long >{

}


application.properties
------------------------
spring.application.name=blog
spring.datasource.url=jdbc:mysql://localhost:3306/myblog
spring.datasource.username=root
spring.datasource.password=test
spring.jpa.hibernate.ddl-auto=update

BlogApplicationTests.java
=========================
package com.blog;

import java.util.List;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.blog.entity.Comment;
import com.blog.entity.Post;
import com.blog.repository.CommentRepository;
import com.blog.repository.PostRepository;

import jakarta.transaction.Transactional;

@SpringBootTest
class BlogApplicationTests {

	@Autowired
	private PostRepository postRepository;
	
	@Autowired
	private CommentRepository commentRepository;

	@Test
	void savePost() {
		Post post = new Post();
		post.setTitle("Hello");
		postRepository.save(post);
		
	}
	@Test
	void addCommentToExistingPost() {
	    Long postId = 1L; // Replace with actual saved post ID
	    Post post = postRepository.findById(postId).orElseThrow();

	    Comment comment = new Comment();
	    comment.setContent("This is a comment after the post was created");
        comment.setPost(post);
        
        commentRepository.save(comment);
	}

	@Transactional
	@Test
	public void getPostAndItsComments() {
	    Post post = postRepository.findById(4L).orElseThrow();
	    List<Comment> comments = post.getComments(); // Works because session is open
	    for (Comment c:comments) {
	    	System.out.println(c.getId());
			System.out.println(c.getContent());
		}
	
	}	
	
	
}

